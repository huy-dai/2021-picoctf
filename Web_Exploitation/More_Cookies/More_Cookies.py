from base64 import b64encode, b64decode
import requests
from requests.cookies import CookieConflictError

#Note: I thought that cookies were specific to each session, though that didn't seem to be the case. You can still submit an old cookie and have it still work.
#session = requests.Session()
#r = session.get('http://mercury.picoctf.net:34962/')
#print(session.cookies.get_dict())
#session.close()
#print(r.text)

cookie_val = 'OFNRcm54eERiaTY0YUhPRyt3dkxiU09taFl3WUZFcWVhVWVwdm42NGZTRW9lejJKbjU3UkwreVB2ZjZzU1RVdU9FMGxvRVFhYzJuelN6NWV3c2tXK05LWmw2YUZwOXNNc2lLREdsVFp6MGhUczIxZmRrQytIbGhWM1lzQ3ArcGI='
#cookie_val = session.cookies.get_dict()["auth_name"]
print("Got cookie:",cookie_val)
raw_cookie = list(b64decode(b64decode(cookie_val)))

print("Raw Cookie:",raw_cookie)
print("Checking myself:",b64encode(b64encode(bytes(raw_cookie))).decode())
print("Equality:",cookie_val == b64encode(b64encode(bytes(raw_cookie))).decode())
input()

# Strategy: Brute Force 
# Assuming that we only need to flip one byte in the problem,
# we want to iterate through all the possible positions in the cookie
# value and try XOR'ing each with a value from 0 to 128.
def flipByte(pos,val,cookie):
    new_val = cookie[pos] ^ val
    new_cookie = cookie.copy()
    new_cookie[pos] = new_val
    output = b64encode(b64encode(bytes(new_cookie)))
    return output.decode()


def run_simulation():
    for pos in range(96):
        for val in range(1,128):
            print("Trying position", pos, "bit=",val)
            res = flipByte(pos,val,raw_cookie)
            custom_cookies = {'auth_name': res}
            r = requests.get('http://mercury.picoctf.net:34962/',cookies=custom_cookies)
            if val == 0:
                with open("temp_result.txt","w") as f:
                    f.write(r.text)
                    continue
            if "alert-success" in r.text or "Welcome to my cookie search page. Only the admin can use it!" not in r.text:
                print(r.text)
                return

run_simulation()