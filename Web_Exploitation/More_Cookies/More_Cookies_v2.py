from base64 import b64encode, b64decode
import concurrent
import requests
from requests.cookies import CookieConflictError

cookie_val = 'UXErRDhEMmNrbTFCV25jbzdheFBjbHNmOWErZnNJdnY5Nk5pUkVNTkVXYUdRK0FVSk9tTGtRT3h1a0dWSDJrbmNHSUxsRTlNR2FZZFJaZ3RRb09EdngyUnd6L3FlbCtPSmZjbnJUVE5pWnVVUHNDQ1lJdFkzbTI4N29NWWxBRU4='
raw_cookie = list(b64decode(b64decode(cookie_val)))

print("Raw Cookie:",raw_cookie)
print("Checking myself:",b64encode(b64encode(bytes(raw_cookie))).decode())
print("Equality:",cookie_val == b64encode(b64encode(bytes(raw_cookie))).decode())

# Strategy: Brute Force 
# Assuming that we only need to flip one byte in the problem,
# we want to iterate through all the possible positions in the cookie
# value and try XOR'ing each with a value from 0 to 128.
def flipByte(pos,val,cookie):
    new_val = cookie[pos] ^ val
    new_cookie = cookie.copy()
    new_cookie[pos] = val
    output = b64encode(b64encode(bytes(new_cookie)))
    return output.decode()

def getCustomCookie(pos,val,cookie):
    cookie_value = flipByte(pos,val,cookie)
    return {'auth_name':cookie_value}

url = 'http://mercury.picoctf.net:34962/'

def request_post_cookies(url, data):
    return requests.post(url, cookies=data)

with concurrent.futures.ThreadPoolExecutor() as executor: # optimally defined number of threads
    res = [executor.submit(request_post_cookies, url, getCustomCookie(pos,val,raw_cookie)) for val in range(128) for pos in range(128)]
    concurrent.futures.wait(res)
    print("Done")

'''
for pos in range(15,128):
    print("Trying position", pos)
    for val in range(128):
        res = flipByte(pos,val,raw_cookie)
        custom_cookies = {'auth_name': res} 
        r = requests.get('http://mercury.picoctf.net:34962/',cookies=custom_cookies)
        if 'picoCTF{' in r.text:
            print(r.text)
            break
'''