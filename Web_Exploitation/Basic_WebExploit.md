# Category: Web Exploitation

## Insp3ct0r

Points: 50

The purpose of this challenge is to teach us to use the "Inspect Page Source" or "Inspect Element" tool. The flag is broken into three parts: the main page, the CSS page, and the JS page.

Flag: picoCTF{tru3_d3t3ct1ve_0r_ju5t_lucky?2e7b23e3}

## Scavenger Hunt

Points: 50

This problem is framed similar to the Insp3ct0r challenge. The flag is divided into multiple parts, which we find in:

1. The main page
2. The CSS page
3. The Javascript page (which contains a hint)
4. robots.txt - this file tells search engine crawler which pages it can access on our website
5. .htaccess - along with .htpasswd, these files are used for managing user access for an Apache server
6. .DS_Store - short for Desktop Services Store, this an invisible file on the macOS operating system that gets automatically created anytime you look into a folder with ‘Finder.’ 

Despite the hint telling us not to, we could have used a directory searcher to automate the process of uncovering hidden files on the website. Specifically, I used `dirsearch` (link: https://github.com/maurosoria/dirsearch), and got the following result:

~~~console
Target: http://mercury.picoctf.net:39698/

[00:14:07] Starting: 
[00:14:09] 200 -   62B  - /.DS_Store
[00:14:10] 200 -   95B  - /.htaccess
[00:14:10] 200 -   95B  - /.htaccess/
[00:14:47] 200 -  961B  - /index.html
[00:15:00] 200 -  124B  - /robots.txt

Task Completed
<<<<<<< Updated upstream
~~~~~
=======
~~~
>>>>>>> Stashed changes

Flag: picoCTF{th4ts_4_l0t_0f_pl4c3s_2_lO0k_fa04427c}

## Some Assembly Required 1

Points: 70

Visiting the website, we see a simple input text box, which, on submission, triggers the onButtonPress() function.

When we visit the Javascript file and passes it through a [deobfuscator](http://jsnice.org/), we get the following:

~~~js
'use strict';
const _0x402c = ["value", "2wfTpTR", "instantiate", "275341bEPcme", "innerHTML", "1195047NznhZg", "1qfevql", "input", "1699808QuoWhA", "Correct!", "check_flag", "Incorrect!", "./JIFxzHyW8W", "23SMpAuA", "802698XOMSrr", "charCodeAt", "474547vVoGDO", "getElementById", "instance", "copy_char", "43591XxcWUl", "504454llVtzW", "arrayBuffer", "2NIQmVj", "result"];
const _0x4e0e = function(url, whensCollection) {
  /** @type {number} */
  url = url - 470;
  let _0x402c6f = _0x402c[url];
  return _0x402c6f;
};
(function(data, oldPassword) {
  const toMonths = _0x4e0e;
  for (; !![];) {
    try {
      const userPsd = -parseInt(toMonths(491)) + parseInt(toMonths(493)) + -parseInt(toMonths(475)) * -parseInt(toMonths(473)) + -parseInt(toMonths(482)) * -parseInt(toMonths(483)) + -parseInt(toMonths(478)) * parseInt(toMonths(480)) + parseInt(toMonths(472)) * parseInt(toMonths(490)) + -parseInt(toMonths(485));
      if (userPsd === oldPassword) {
        break;
      } else {
        data["push"](data["shift"]());
      }
    } catch (_0x41d31a) {
      data["push"](data["shift"]());
    }
  }
})(_0x402c, 627907);
let exports;
(async() => {
  const findMiddlePosition = _0x4e0e;
  let leftBranch = await fetch(findMiddlePosition(489));
  let rightBranch = await WebAssembly[findMiddlePosition(479)](await leftBranch[findMiddlePosition(474)]());
  let module = rightBranch[findMiddlePosition(470)];
  exports = module["exports"];
})();
/**
 * @return {undefined}
 */
function onButtonPress() {
  const navigatePop = _0x4e0e;
  let params = document["getElementById"](navigatePop(484))[navigatePop(477)];
  for (let i = 0; i < params["length"]; i++) {
    exports[navigatePop(471)](params[navigatePop(492)](i), i);
  }
  exports["copy_char"](0, params["length"]);
  if (exports[navigatePop(487)]() == 1) {
    document[navigatePop(494)](navigatePop(476))[navigatePop(481)] = navigatePop(486);
  } else {
    document[navigatePop(494)](navigatePop(476))[navigatePop(481)] = navigatePop(488);
  }
}
;
~~~

We want to focus on the exports and `onButtonPress` function. At the moment, it is difficult to understand the code without understanding the logic of findMiddlePosition() and navigatePop().

Using the developer console, we can easily retrieve it by first defining the constant as in the Javascript file and then trying out some of the function calls ourselves:

~~~js
>> const navigatePop = _0x4e0e;
undefined
>> navigatePop(484)
"input"
>> navigatePop(471)
"copy_char"
>> navigatePop(492)
"charCodeAt"
~~~

We can see that `navigatePop` has the responsibilty of retrieving specific text stored on the website. By replicating the same steps for `findMiddlePosition`, we also find it performs a similar operation as well.

By subsituting out the function calls with the corresponding text, we get:

~~~js
let exports;
(async() => {
  const findMiddlePosition = _0x4e0e;
  let leftBranch = await fetch("./JIFxzHyW8W");
  let rightBranch = await WebAssembly["instantiate"](await leftBranch["arrayBuffer"]());
  let module = rightBranch["instance"];
  exports = module["exports"];
})();
/**
 * @return {undefined}
 */
function onButtonPress() {
  const navigatePop = _0x4e0e;
  let params = document["getElementById"]("input")["value"];
  for (let i = 0; i < params["length"]; i++) {
    exports["copy_char"](params["charCodeAt"](i), i);
  }
  exports["copy_char"](0, params["length"]);
  if (exports["check_flag"]() == 1) {
    document["getElementById"]("result")["innerHTML"] = "Correct!";
  } else {
    document["getElementById"]("result")["innerHTML"] = 
    "Incorrect");
  }
}
;
~~~

Within onButtonPress we can see the the script is taking each character of the input string induvidually and sending it to a function called "copy_char". After which, it calls check_flag to compare if the flag and submitted string is the same. 

Based on the exports statement, we can assume that "copy_char" is sending the characters of the input string to a WebAssembly script at "/JIFxzHyW8W".

We can down the WebAssembly script using `wget`:

~~~console
$ wget http://mercury.picoctf.net:36152/JIFxzHyW8W -O script.wasm

$ file script.wasm 
script.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
~~~

For reference, WebAssembly or Wasm for short is a compact binary instruction format that can be run on modern web browsers. It has a low-level assembly-like language and is used as a portable compilation target for programming languages like C/C++, C$, and Rust. WebAssembly is designed to complement and run alongside Javascript. For information, check out the link [here](https://developer.mozilla.org/en-US/docs/WebAssembly).

To allow WebAssembly to be read and edited by a human, there is a textual representation of the wasm binary format, which stores files with the extension .wat

For us to convert wasm files into wat, we need the `wasm2wat` tool, which is a part of the WABT library. [Link](https://github.com/webassembly/wabt)


We can install the package on Ubuntu using:

`sudo apt-get install wabt`

and then convert the wasm file into .wat by doing:

```console
$ wasm2wat --generate-names script.wasm > script.wat
```

Now if we scroll all the way to the bottom we can find the flag in cleartext:

~~~wat
  (export "strcmp" (func $strcmp))
  (export "check_flag" (func $check_flag))
  (export "input" (global 1))
  (export "copy_char" (func $copy_char))
  (export "__dso_handle" (global 2))
  (export "__data_end" (global 3))
  (export "__global_base" (global 4))
  (export "__heap_base" (global 5))
  (export "__memory_base" (global 6))
  (export "__table_base" (global 7))
  (data $d0 (i32.const 1024) "picoCTF{d88090e679c48f3945fcaa6a7d6d70c5}\00\00"))
~~~

In the file we see three functions, namely strcmp, check_flag, and copy_char.

For context, Web Assembly can be thought of as a *stack machine*. It's basically composed of instructions which push the value to the stack and/or pop it from the stack to a different location. 

For example, a `local.get` instruction pushes a value from a local variable to the stack, a `local.set` instruction pops a value from the stack and pushes it to a local, and an instruction like `i32.sub` performs an operation on values popped from the stack and pushes the result to the stack.

Within the wabt package there is a number of tools to try to compile the code to higher languages like C (e.g., wasm2c).

However, in our case, running the conversion yield a very non-helpful result:

~~~c
static void copy_char(u32 p0, u32 p1) {
  u32 l2 = 0, l3 = 0, l4 = 0, l5 = 0, l6 = 0;
  FUNC_PROLOGUE;
  u32 i0, i1;
  i0 = g0;
  l2 = i0;
  i0 = 16u;
  l3 = i0;
  i0 = l2;
  i1 = l3;
  i0 -= i1;
  l4 = i0;
  i0 = l4;
  i1 = p0;
  i32_store((&memory), (u64)(i0 + 12), i1);
  i0 = l4;
  i1 = p1;
[...]
~~~

The best option we seem to have for this exercise is to decompile the code into pseudocode using `wasm-decompile`:

`wasm-decompile script.wasm -o script.dcmp`

The result:

~~~pseudo
export memory memory(initial: 2, max: 0);

global g_a:int = 66864;
export global input:int = 1072;
global dso_handle:int = 1024;
global data_end:int = 1328;
global global_base:int = 1024;
global heap_base:int = 66864;
global memory_base:int = 0;
global table_base:int = 1;

table T_a:funcref(min: 1, max: 1);

data d_a(offset: 1024) = 
"picoCTF{d88090e679c48f3945fcaa6a7d6d70c5}\00\00";

function wasm_call_ctors() {
}

[...]

export function check_flag():int {
  var a:int = 0;
  var b:int = 1072;
  var c:int = 1024;
  var d:int = strcmp(c, b);
  var e:int = d;
  var f:int = a;
  var g:int = e != f;
  var h:int = -1;
  var i:int = g ^ h;
  var j:int = 1;
  var k:int = i & j;
  return k;
}

function copy(a:int, b:int) {
  var c:int = g_a;
  var d:int = 16;
  var e:int_ptr = c - d;
  e[3] = a;
  e[2] = b;
  var f:int = e[3];
  var g:byte_ptr = e[2];
  g[1072] = f;
}
~~~

We see from the decompiled code that `copy` takes in two parameters, 'a' and 'b', which we know from the Javscript file is a sample character from the user input and its index in the string. The function then stores the character at offset `1072 + b`. Essentially the program is just storing the flag from offset 1072 and onward.

`check_flag` is responsible for calling strcmp between the string starting at offset 1072 (our user input) and 1024 (presumbably to be the flag). It then performs some manipulations on the result, which the writeup that I was referencing (link](https://github.com/Dvd848/CTFs/blob/master/2021_picoCTF/Some_Assembly_Required_1.md)), says to be equivalent to `(((strcmp_res != 0) ^ (-1)) & 1)`. This seems to be a more complicated way of saying if `strcmp` returned 0 (i.e., the strings are equal) then the return value will 1, and 0 otherwise.

Flag: picoCTF{d88090e679c48f3945fcaa6a7d6d70c5}

## More Cookies

Points: 90

**Prompt:** I forgot Cookies can Be modified Client-side, so now I decided to encrypt them! <http://mercury.picoctf.net:34962/>

*Hint 1:* <https://en.wikipedia.org/wiki/Homomorphic_encryption>

*Hint 2:* The search endpoint is only helpful for telling you if you are admin or not, you won't be able to guess the flag name

When we open the webpage, we are greeted with the message: "Welcome to my cookie search page. Only the admin can use it!". Using a Cookie Manager on Firefox, we are able to see that the website has one cookie named `auth_name` with the value:

`V2FObFBadFplai9hT0JXWWpndU1ETlNUczZ6M1lqNDdNbHRrc1M4N1ppS2ZxMFZHTEdncjV4ckc1U2Z5OUp0TTF1Rks4dlJPbVFNMEZ4NDYyZnkvNnozaHp6MDNLTTBiR0paZ01CRHIzNGZEb3E4cnhqcXVndDJReFVWdyswZGY=`

Decoding from base64, we get the encrypted text:

`WaNlPZtZej/aOBWYjguMDNSTs6z3Yj47MltksS87ZiKfq0VGLGgr5xrG5Sfy9JtM1uFK8vROmQM0Fx462fy/6z3hzz03KM0bGJZgMBDr34fDoq8rxjqugt2QxUVw+0df`

From the hint, we know won't be able to decrypt the cookie to get the flag. Paying closer attention to the prompt, we notice that the capitalized letters spells out "CBC", which points to the encryption being Cipher Block Chaining method. If the cookie is used for authorizing admin access, we can assume that there must some text like `auth=0` in the cookie that the server is checking for. For CBC encryption, there is the CBC byte-flipping attack which we can use to change one value in the cookie. For a more detailed reading see [here](https://resources.infosecinstitute.com/topic/cbc-byte-flipping-attack-101-approach/).

The encryption and decryption method using CBC mode is as follows:

![Encryption Method](./More_Cookies/encrypt.png)

CBC works on a fixed-group group of bits called a block (for example, AES-CBC uses 128 bit blocks). At the start, a block of plaintext is XOR with the Intialization Vector (IV). Their result is fed into the block cipher encryption algorithm, along with a key if the algorithm is symmetric (e.g., if we are using DES, Blowfish, AES, etc.) The IV key is used to randomize the encryption so that we will get different results even if the same starting plaintext is used across multiple messages. Afterwards, the ciphertext of the first block will be used to XOR with next block of bytes, which will then be fed into the encryption algorithm to get the next block of ciphertext. The process repeats until all blocks have been encrypted.

![Decryption Method](./More_Cookies/decrypt.png)

To decrypt, the reverse is done. We first feed the first block's ciphertext into the algorithm with the key (if symmetric) to decrypt, and then we XOR the result with the IV. Since `A ^ B ^ B = A ^ 0 = A` for any given A and B, we would get back our original text. The first block ciphertext is also used to XOR with the result of the decryption algorithm on the second block to yield the original second block text. This process is repeated until all blocks have been decrypted.

Now we turn our attention into the byte-flipping method:

![Byte-Flipping Method](./More_Cookies/byte_flipping.jpg)

The way the CBC Byte-Flipping attack works is that by altering one byte of a given ciphertext block, we would end up with likely a garbled plaintext for that block, but we would also be affect the result of the next block (due to the XOR operation). In theory, this allows us to have control over one byte of the plaintext result for the next block over.

For example, let's say we have the following trivial example:

We are given the ciphertext that has been encrypted with a symmetric encryption algorithm using CBC (Cipher Block Chaining) mode. We know that in the second block there is some encrypted text, say, "var1:6" that we want to change to be "var1:7". If we want for the 6th character to be decrypted as the number '7' rather than '6', what we would do is change the 6th encrypted character in the **FIRST** block, call it `x`, to be:

`chr(ord(x) ^ ord("6") ^ ord("7"))`

This is because once the second block passes through the decryption algorithm, that result (which should be equal to '6' ^ x) gets XOR'ed with our modified plaintext, yielding:

`('6' ^ x) ^ (x ^ '6' ^ '7')`

`= '6' ^ '6' ^ 'x' ^ 'x' ^ '7' `

`= 0 ^ 0 ^ '7' = '7'`

Thus we were able to modify the decrypted plaintext of the second block by changing the ciphertext of the first block.

Even with the referenced code from previous writeups, the solution still took me a couple of hours between putting the code together, debug, and performing trial-runs. The problem was that the challenge has been revised multiple times by PicoCTF, though I didn't realize that so until much later in the troubleshooting steps.

You can find the full exploit script in `More_Cookies.py`. The main part is the `flipByte` function, which took in a `pos` index (the target index), a integer `val` (the value to XOR with), and `cookie` representing the cookie value in raw bytes:

~~~py
def flipByte(pos,val,cookie):
    new_val = cookie[pos] ^ val
    new_cookie = cookie.copy()
    new_cookie[pos] = new_val
    output = b64encode(b64encode(bytes(new_cookie)))
    return output.decode()
~~~

I then ran a simulation to iterate across the length of the cookie value and try XOR'ing with values between 0-125:

~~~py
def run_simulation():
    for pos in range(96):
        for val in range(1,128):
            print("Trying position", pos, "bit=",val)
            res = flipByte(pos,val,raw_cookie)
            custom_cookies = {'auth_name': res}
            r = requests.get('http://mercury.picoctf.net:34962/',cookies=custom_cookies)
            if val == 0:
                with open("temp_result.txt","w") as f:
                    f.write(r.text)
                    continue
            if "alert-success" in r.text or "Welcome to my cookie search page. Only the admin can use it!" not in r.text:
                print(r.text)
                return

run_simulation()
~~~

My stop condition was when either when we get an alert-success letting us know something was submitted correctly or us seeing main page message changing. The true stop condition turned out to be the latter.

There were a number of things that I learned while writing / troubleshotting this script:

1. Weirdly enough, the cookie was actually twice encoded with base64. You know that you've gotten down to the correct encrypted formatting if you see a lot of weird character and/or blank spaces.

2. Due to the way that the PicoCTF sets up the challenge webpage, there are multiple cookies which can be in effect any time (I honestly should have realized this one myself). I panicked a little when I was using Sessions.get() and saw that my `auth_name` value kept changing, as I was worried that the cookie value was only effective within each session.

3. Despite there being a hint about web page having a `search` endpoint and not showing the flag directly, PicoCTF seemed to have removed this feature and instead displayed the flag right on the webpage whenever we trigger a sucessful cookie byte-flip.

The successful byte-flip was at position 9, with us XOR'ing the cookie value with the integer '1'.

Flag: picoCTF{cO0ki3s_yum_e40d16a9}


## Where are the robots

Points: 90

It's actually funny how greatly the difficulty ranges from problem to problem, even between those valuing at the same amount of points. The main webpage, it talks about finding the robots, which we can assume to be the `robots.txt`. Navigating to <https://jupiter.challenges.picoctf.org/problem/56830/robots.txt>, we find a "Disallow" entry for `1bb4c.html`. Navigating there, we get the flag.

Flag: picoCTF{ca1cu1at1ng_Mach1n3s_1bb4c}